<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>network on Cactus theme example</title>
    <link>https://example.com/tags/network/</link>
    <description>Recent content in network on Cactus theme example</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>You</copyright>
    <lastBuildDate>Tue, 25 Feb 2020 09:04:20 +0800</lastBuildDate><atom:link href="https://example.com/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从Nat到TCP_TW</title>
      <link>https://example.com/posts/tcp_nat/</link>
      <pubDate>Tue, 25 Feb 2020 09:04:20 +0800</pubDate>
      
      <guid>https://example.com/posts/tcp_nat/</guid>
      <description>看到这个标题，你可能会感到疑惑这两个有什么关系呢？一个是IP转换一个是TCP，似乎关系不大？接下来听我慢慢介绍。
NAT 在IPV4的时代，IP可以分为两种，公网和局域网。当你在局域网时想要访问外面的内容就要经过Nat，即网络地址转换也就是把局域网的IP转换为公网，发送和接收请求。其中
 SNat 原地址转换 Source nat，也就是在发送请求的时候，我们的路由器把类似192.168.1.2转换为我们拨号上网的公网IP， DNat也就是目的地址转换，也就是在收到接收到请求的时候，把上面的公网IP转换为192.168.1.2的局域网IP。  也就是说其实我们无时无刻都在使用着Nat，这是客户端。对于服务端呢？也会用到Nat。典型的场景比如负载均衡。比如说我们请求的淘宝首页，淘宝的服务器肯定不止一台，淘宝可能也是通过负载均衡以及Nat来把请求分发到后端。
1dig A taobao.com +short 2140.205.220.96 3140.205.94.189 TCP 为什么会注意到这点呢？其实主要是因为部署在容器内的服务在连接MySQL的时候经常会报错比如：
1pymysql.err.OperationalError: (2003, &amp;#34;Can&amp;#39;t connect to MySQL server on &amp;#39;xxxx (timed out)&amp;#34;) 2Error Code: 2013. Lost connection to MySQL server during query 主要的原因就是因为开发TCP timewait的复用。这里引用下别人的文章：
11. 同时开启tcp_timestamp和tcp_tw_recycle会启用TCP/IP协议栈的per-host的PAWS机制 22. 经过同一NAT转换后的来自不同真实client的数据流，在服务端看来是于同一host打交道 33. 虽然经过同一NAT转化，但由于不同真实client会携带各自的timestamp值 4因而无法保证整过NAT转化后的数据包携带的timestamp值严格递增 54. 当服务器的per-host PAWS机制被触发后，会丢弃timestamp值不符合递增条件的数据包 先说结论
 开启tcp_timestamp，但不要开tcp_tw_recycle
 TCP的三次握手这些就不多说了，下面就根据流程图以及Linux kernel相关TCP参数补充一下细节。
1客户端 服务端 2 + + 3 | | 4 | | Listen 监听端口 5 | | 6 | | 7+------------------------------------------------------------------+ 8发送SYN,(SYN_SEND) | | 9 | | 10 | | 回复SYN+ACK，到SYN_RCVD 11 | | 12 回复ACK | | 13 | | 14+------------------------------------------------------------------+ 建立连接 15 建立链接 | | 建立链接 16 双方开始传输数据 | | 双方开始传输数据 17 | | 18 GET / HTTP1.</description>
    </item>
    
    <item>
      <title>Kubernetes 中的网络结构</title>
      <link>https://example.com/posts/kubernetes-network-flannel/</link>
      <pubDate>Tue, 12 Feb 2019 22:31:20 +0800</pubDate>
      
      <guid>https://example.com/posts/kubernetes-network-flannel/</guid>
      <description>Kubernetes 采用的是基于扁平地址空间的网络模型，集群中的每个 Pod 都有自己的 IP 地址，Pod 之间不需要配置 NAT 就能直接通信。另外，同一个 Pod 中的容器共享 Pod 的 IP，能够通过 localhost 通信。
  IP-per-Pod，每个 Pod 都拥有一个独立 IP 地址，Pod 内所有容器共享一个网络命名空间
  集群内所有 Pod 都在一个直接连通的扁平网络中，可通过 IP 直接访问
 所有容器之间无需 NAT 就可以直接互相访问 所有 Node 和所有容器之间无需 NAT 就可以直接互相访问 容器自己看到的 IP 跟其他容器看到的一样    接下来我们来先介绍一下几个概念，
 Service cluster IP 尽可在集群内部访问，外部请求需要通过 NodePort、LoadBalance 或者 Ingress 来访问 网络的命名空间：Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；docker利用这一特性，实现不容器间的网络隔离。 Veth设备对：Veth设备对的引入是为了实现在不同网络命名空间的通信。 Iptables/Netfilter：Netfilter负责在内核中执行各种挂接的规则(过滤、修改、丢弃等)，运行在内核 模式中；Iptables模式是在用户模式下运行的进程，负责协助维护内核中Netfilter的各种规则表；通过二者的配合来实现整个Linux网络协议栈中灵活的数据包处理机制。 网桥：网桥是一个二层网络设备,通过网桥可以将linux支持的不同的端口连接起来,并实现类似交换机那样的多对多的通信。 路由：Linux系统包含一个完整的路由功能，当IP层在处理数据发送或转发的时候，会使用路由表来决定发往哪里  如今，Kubernetes改变了软件开发的完成方式。作为用于管理容器化工作负载和服务的便携式，可扩展的开源平台，该平台可促进声明式配置和自动化，Kubernetes已证明自己是管理复杂微服务的主导者。它的受欢迎程度源于Kubernetes满足以下需求的事实：企业希望增长和减少支付，DevOps需要一个稳定的平台，可以大规模运行应用程序，开发人员想要可靠且可复制的流程来编写，测试和调试代码。这是一篇很好的文章，可以了解有关Kubernetes演化和架构的更多信息。
管理Kubernetes网络的重要领域之一是在内部和外部转发容器端口，以确保容器和Pod可以正确相互通信。为了管理此类通信，Kubernetes提供以下四种联网模型：
 容器到容器通信 点对点通讯 Pod到Service通讯 对外沟通  在本文中，我们通过向您展示Kubernetes网络中的Pod可以相互通信的方式，深入探讨Pod到Pod的通信。</description>
    </item>
    
  </channel>
</rss>
