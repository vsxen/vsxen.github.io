<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Cactus theme example</title>
    <link>https://example.com/tags/linux/</link>
    <description>Recent content in Linux on Cactus theme example</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>You</copyright>
    <lastBuildDate>Sun, 07 Mar 2021 09:10:53 +0800</lastBuildDate><atom:link href="https://example.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何为CentOS7升级4.x内核</title>
      <link>https://example.com/posts/uprade-kernel/</link>
      <pubDate>Sun, 07 Mar 2021 09:10:53 +0800</pubDate>
      
      <guid>https://example.com/posts/uprade-kernel/</guid>
      <description>默认的CentOS 7 使用的是 3.x版本的内核，比如 7.3使用的是3.10.0-957.5.1.el7.x86_64，大版本号也就是3.10.0，后面的957也就是不断的维护的小版本，如果你不升级的话，仅仅是update的话，只会增加最后的小版本号。但是当我们想使用高版本内核才支持的特性的时候，就需要升级。打开https://www.kernel.org/ 你会发现有下面几个版本：那怎么才能找到需要的版本的包呢？
   mainline: 5.13-rc1 2021-05-09     stable: 5.12.4 2021-05-14   stable: 5.11.21 2021-05-14   longterm: 5.10.37 2021-05-14   longterm: 5.4.119 2021-05-14   longterm: 4.19.190 2021-05-07   longterm: 4.14.232 2021-04-28   longterm: 4.9.268 2021-04-28   longterm: 4.4.268 2021-04-28   linux-next: next-20210514 2021-05-14    首先我们来看下最小化系统默认安装了哪些kernel相关的包：
1# rpm -qa |grep kernel 2kernel-3.10.0-957.5.1.el7.x86_64 3kernel-tools-3.10.0-957.5.1.el7.x86_64 4kernel-headers-3.</description>
    </item>
    
    <item>
      <title>从Nat到TCP_TW</title>
      <link>https://example.com/posts/tcp_nat/</link>
      <pubDate>Tue, 25 Feb 2020 09:04:20 +0800</pubDate>
      
      <guid>https://example.com/posts/tcp_nat/</guid>
      <description>看到这个标题，你可能会感到疑惑这两个有什么关系呢？一个是IP转换一个是TCP，似乎关系不大？接下来听我慢慢介绍。
NAT 在IPV4的时代，IP可以分为两种，公网和局域网。当你在局域网时想要访问外面的内容就要经过Nat，即网络地址转换也就是把局域网的IP转换为公网，发送和接收请求。其中
 SNat 原地址转换 Source nat，也就是在发送请求的时候，我们的路由器把类似192.168.1.2转换为我们拨号上网的公网IP， DNat也就是目的地址转换，也就是在收到接收到请求的时候，把上面的公网IP转换为192.168.1.2的局域网IP。  也就是说其实我们无时无刻都在使用着Nat，这是客户端。对于服务端呢？也会用到Nat。典型的场景比如负载均衡。比如说我们请求的淘宝首页，淘宝的服务器肯定不止一台，淘宝可能也是通过负载均衡以及Nat来把请求分发到后端。
1dig A taobao.com +short 2140.205.220.96 3140.205.94.189 TCP 为什么会注意到这点呢？其实主要是因为部署在容器内的服务在连接MySQL的时候经常会报错比如：
1pymysql.err.OperationalError: (2003, &amp;#34;Can&amp;#39;t connect to MySQL server on &amp;#39;xxxx (timed out)&amp;#34;) 2Error Code: 2013. Lost connection to MySQL server during query 主要的原因就是因为开发TCP timewait的复用。这里引用下别人的文章：
11. 同时开启tcp_timestamp和tcp_tw_recycle会启用TCP/IP协议栈的per-host的PAWS机制 22. 经过同一NAT转换后的来自不同真实client的数据流，在服务端看来是于同一host打交道 33. 虽然经过同一NAT转化，但由于不同真实client会携带各自的timestamp值 4因而无法保证整过NAT转化后的数据包携带的timestamp值严格递增 54. 当服务器的per-host PAWS机制被触发后，会丢弃timestamp值不符合递增条件的数据包 先说结论
 开启tcp_timestamp，但不要开tcp_tw_recycle
 TCP的三次握手这些就不多说了，下面就根据流程图以及Linux kernel相关TCP参数补充一下细节。
1客户端 服务端 2 + + 3 | | 4 | | Listen 监听端口 5 | | 6 | | 7+------------------------------------------------------------------+ 8发送SYN,(SYN_SEND) | | 9 | | 10 | | 回复SYN+ACK，到SYN_RCVD 11 | | 12 回复ACK | | 13 | | 14+------------------------------------------------------------------+ 建立连接 15 建立链接 | | 建立链接 16 双方开始传输数据 | | 双方开始传输数据 17 | | 18 GET / HTTP1.</description>
    </item>
    
  </channel>
</rss>
